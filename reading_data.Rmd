---
title: 'Считывание нескольких файлов'
output: html_document
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE)
```

##Общие вещи
Подгружаем библиотеки, которые потом понадобятся:


```{r libraries, eval = FALSE}
library("openxlsx")  # for xlsx
library("gdata")  # for xls
library("dplyr") # for handling failures while reading files
```


Получим список, интересующих нас файлов. Для этого пользуемся функцией `list.files()`. У функции есть несколько аргументов, самые важные сейчас это _path_, которой обозначает интересующую нас папку, и _pattern_, с помощью, которого можно ограничить набор файлов по наличию нужной фразы в названии. 

Пример использования аргумента _pattern_: пусть все файлы в папке называются по двум типа "Имя\_региона\_ГОС.xlsx" и "Имя\_региона\_НЕГОС.xlsx". Чтобы в полученном списке файлов были только только файлы, оканчивающиеся на "НЕГОС", мы добавляем эту фразу в качестве значения аргумента _pattern_. Возможны более сложные запросы с использованием регулярных выражений.


```{r list files, eval = FALSE}
filelist <- list.files(path = "your_directory_with_files", 
                       pattern = "filename_pattern")
```


##CSV или TXT файлы
Чтобы просто считать .csv файл достаточно воспользоваться функцией `read.csv()`. Воспользуемся ей и функционалом `lapply()`, чтобы считывать сразу несколько файлов. Результат будет храниться в переменной типа _list_. Первый аргумент `lapply()` -  список файлов, полученный ранее. Потом идёт функция, которую мы применяем к каждому из элементов списка: в нашем случае нужно прочесть каждый файл из списка, поэтому мы применяем `read.csv()`. В качестве третьего и последующего аргументов просто добавляем опции из функции 'read.csv'. Поскольку интересующие нас файлы обычно хранятся в отдельной папке, добавим её название к имени каждого файла, чтобы R мог найти их при считывании. Используем функцию `paste0()`. Ваша папка должна лежать внутри рабочей папки для данного проекта (working directory).


```{r lapply csv, eval = FALSE}
data <- lapply(paste0("your_directory_name/", filelist), 
               read.csv, 
               read.csv_arg_1,
               read.csv_arg_2, ...)  # general case

data <- lapply(paste0("your_directory_name/", filelist), 
               read.csv, 
               header = TRUE, 
               stringsAsFactors = FALSE)  # example
```


Если все файлы в папке разные и нет цели сливать их в один, то чтобы получить данные из определенного файла, достаточно присвоить новое имя элементу list'a: 


```{r, get element of a list, eval = FALSE}
new_element <- data[[number of your element]]  # general case
new_element <- data[[1]]  # example
```


Если структура всех файлов в папке одинаковая (все они описывают одни и те же переменные и эти переменные названы одинаково), сольём их в одну таблицу с данными с помощью команд `Reduce()` и `rbind()`. Первая используется для рекурсивного повторения операций, вторая для сливая двух таблиц по принципу вертикальной склейки.


```{r csv, eval = FALSE}
data_in_table <- Reduce(rbind, data)
```


##XLSX
Чтобы просто считать несколько .xlsx файлов просто меняем функцию, которая читает файлы в нашем функционале:


```{r lapply xlsx, eval = FALSE}
data_xlsx <- lapply(paste0("your_directory_name/", filelist), 
                    read.xlsx, 
                    read.xlsx_arg_1, 
                    read.xlsx_arg_2, ...)  # general case

data_xlsx <- lapply(paste0("your_directory_name/", filelist), 
                    read.xlsx, 
                    sheet = 1)  # example
```


Остальные шаги аналогичны прошлому подпункту.


##XLS
В общем случае пример с .xls файлами практически не отличается от считывания .xlsx - достаточно просто заменить функцию `read.xlsx()` из пакета `openxlsx` на функцию `read.xls()` из пакета `gdata`.


Посмотрим на конкретный пример считывания нескольких .xls файлов, содержащих данные о приемных кампаниях в университеты в регионах России. Пример паттерна, который содержат названия интересующих нас файлов: "Алтайский край\_ГОС_Заочная.xls". 


Создаём список файлов. Файлы лежат в папке с названием "Государственные"; каждый из интересующих нас файлов содержат фразу "Заочная" в названии.


```{r filepath, eval = FALSE}
filelist.extern <- list.files(path = "Государственные", pattern = "Заочная")
```


Заранее задаём вектор, содержащий новые названия столбцов в интересующей нас таблице.


```{r colnames, eval = FALSE}
columns <- c("specialization", "type", "code",
             "applicants", "admitted.all", "adm.fed",
             "adm.subj", "adm.local", "adm.com") 
```


Создаём "обертку" для функции `read.xls()`, чтобы сразу получать нужные данные. Здесь добавление названия папки, содержащей данные, уже добавлено в саму читающую функцию - см. первый аргумент функции `read.xls()` внутри функции `readRenameSubset()`. 


```{r read single, eval = FALSE}
readRenameSubset <- function(file, path, phrase.pattern, column.names, prog.type, key.one, key.two) {
  d <- read.xls(paste0(path, file), # Файл с данными
                # Лист из книги, с которого мы хотим считать данные
                sheet = 4,  
                
                # Данные читаются со строки, следующей за строкой, содержащей phrase.pattern
                pattern = phrase.pattern,  
                
                # Выключить автоматическую конвертацию в факторные переменные
                stringsAsFactors = FALSE)
  
  # Присвоить таблице названия колонок, заданные на прошлом шаге
  colnames(d) <- column.names 
  
  # Оставить только определенный тип программ (бакалавриат, специалитет etc.)
  d <- filter(d, type == prog.type) 
  
  # Добавляем название региона в данные из имени файла (см. пример дальше)
  d$region <- gsub(key.one, "", file) 
  
  # Добавляем категорию для данных (см. пример дальше)
  d$category <- key.two 
  return(d)
}
```


Используем функционал `lapply()` по ранее введённой схеме. Первый аргумент - список файлов, которые мы читаем. Второй - функция, которая читает файлы. Если происходит ошибка при считывании файла (допустим в регионе нет программ бакалавриата), цикл чтения файлов продолжается, а в строку, где произошла ошибка записывается `NA`. Это реализовано с помощью функции `failwith()` из пакета `dplyr`. Остальные аргументы - дополнительные аргументы функции, читающий файл (в данном случае функции `readRenameSubset()`). 


```{r read all, eval = FALSE}
extern.by.reg <- lapply(filelist.extern,  # список файлов, полученный ранее
                        
                        # функция, читающая файлы
                        failwith(NA, readRenameSubset),
                        
                        # папка с файлами для считывания
                        path = "Государственные/",  
                        
                        # будут считаны строки после строки с фразой "Программы бакалавриата"
                        phrase.pattern = "Программы бакалавриата", 
                        
                        # названия переменных
                        column.names = columns,  
                        
                        # выбираем определенный тип программ, чтобы не хранить лишние данные (1 - бакалавриат)
                        prog.type = 1,  
                        
                        # убираем лишние данные из названия файла, чтобы в табличке было чистое название региона
                        key.one = "_ГОС_Заочная.xls", 
                        
                        # создаем идентификатор, чтобы потом сливать данные с очными и очно-заочными таблицами
                        key.two = "Заочная") 
```                        


Сливаем все файлы в одну таблицу уже введенному методу:


```{r final data, eval = FALSE}             
extern.all <- Reduce(rbind, extern.by.reg)
```