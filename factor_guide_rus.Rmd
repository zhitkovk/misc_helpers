---
title: "Дамми и категориальные переменные в R"
author: Константин Житков
output: html_document
---
  
  
## Базовые настройки
  

Начнем с технического момента: установим несколько настроек, чтобы получить итоговый документ без информации о его создании, а также подключим библиотеки для построения графиков и работы с факторными переменными (о том, что такое факторные переменные будет сказано чуть ниже).
  
  
```{r, icnlude = FALSE}
knitr::opts_chunk$set(warning = FALSE)  # убрать предупреждения из документа
knitr::opts_chunk$set(message = FALSE)  # убрать сообщения из документа
```


```{r}
library("ggplot2")  # построение графиков 
library("forcats")  # работа с факторными переменными
```


## Самый просто способ создания дамми переменной (индикатора)


Загрузим данные для построения примеров:
  
  
```{r}
data <- mtcars
```


#### Категориальная переменная с двумя уровнями


```{r}
dummy1 <- ifelse(mtcars$hp > 90, "категория1", "категория2")
table(dummy1)
```


#### Простой индикатор


```{r}
dummy2 <- ifelse(mtcars$hp > 90, 1, 0)
table(dummy2)
```


#### Функция `factor()`


В R дамми и категориальные переменные обычно представляются с помощью факторных переменных. По своей сути переменная типа фактор это числовой (numeric или integer) или текстовый вектор (character) с группировкой каждого уникального значения по категориям/уровням (levels). 


Принцип работы команды проще понять с помощью примеров. Уровни (levels) автоматически устанавливаются на основе уникальных значений:

  
```{r}
fact1 <- factor(c(1, 1, 2))
fact2 <- factor(c("one", "one", "two"))

fact1

fact2
```


Уровням можно давать свои имена. Значения уровней (levels) получены из вектора лэйблов (labels):
  
  
```{r}
fact <- factor(c(1, 1, 2), labels = c("foo", "bar"))

fact
```


Уровни (levels) указаны, но вектор содержит только NA: дело в том, что если уровни (levels) выставлены, то предполагается, что вектор содержит именно эти значения. R пытается найти их в векторе, но не находит и сохраняет заданные значения уровней (levels), отмечая, что наблюдений таких категорий у нас нет:
  
  
```{r}
fact <- factor(c(1, 1, 2), levels = c("foo", "bar"))

fact
```


Пример возможного использования команды `levels`:
  
  
```{r}
fact1 <- factor(c(1, 1, 2), levels = c("1", "2"))
fact2 <- factor(c(1, 1, 2), levels = c("1", "2", "3"))
```


В первом случае мы прописали руками то, что R делает автоматически (создание категорий (уровней/levels) на основе уникальных значений):


```{r}
fact1
```


Во втором случае одному из уровней (level) не соответствует ни одного наблюдения:


```{r}
fact2
```


Иногда нам не нравятся названия уровней (levels), полученные на основе уникальных значений вектора. Разберёмся с тем, как переименовать их.


Создаём фактор с уровнями (levels) "1" и "2". Проверяем, что они действительно такие с помощью функции `levels()`:


```{r}
fact <- factor(c(1, 1, 2)) 
levels(fact)
```


Переименовываем их в "one" и "two" с помощью той же функции:


```{r}
fact <- factor(c(1, 1, 2)) 
levels(fact) <- c("one", "two")

fact
```


Часто после сортировки и фильтрации данных некоторые наблюдения удаляются из выборки. Может так случиться, что теперь какому-то из уровней (level) факторной переменной не соответсвует ни одного наблюдения. Чтобы не таскать за собой эту информацию можно воспользоваться функцией `droplevels()`.


Тоже самое на примере. Создаём фактор:


```{r}
fact <- factor(c(1, 1, 2))
```


Удаляем одно наблюдение:


```{r}
fact <- fact[1:2]
```


Теперь у нас есть один __неиспользованный__ уровень (level). Удалим его:
  
  
```{r}
fact <- droplevels(fact)
fact
```


Ещё одной ситуацией требующей манипуляции над факторной переменной является построение регрессии. Мы часто хотим, чтобы __базовой__ категорией была какая-то определенная (женщина, а не мужчина, общее образование, а не среднепрофессиональное etc). Установить такую категорию не сложно: 
  
  
```{r}
fact <- factor(c(1, 1, 2))
fact <- relevel(fact, ref = "2")
```


Теперь "2" стоит в начале:
  
  
```{r}
fact
```


#### Объединение редких уровней (levels) в одну категорию ("другое")


Предположим, что на один из вопросов из социологического опроса есть 5 вариантов ответа и большинство людей остановились на первых трёх: 100 человек выбрали первый, 200 второй, 150 третий, 10 четвертый и 7 пятый. Последние два варинта ответа редкие и говорят о каких-то необычных активностях. Такая детализация не всегда нужна, поэтому можно объединить их в одну категорию, к примеру, "другое". 


Такие действия приходится производить достаточно часто. Существуют уже готовые решения для подобных манипуляций (пакет `forcats`), но мы начнем раздел с написанной самостоятельно функции, чтобы лучше понимать как происходят манипуляции с уровнями факторной переменной. На вход функция получает факторную переменную и минимальное количество наблюдений, чтобы категория осталась самостоятельной. Результат применения функции: факторная переменная с редкими уровнями, слитыми в новый уровень (level):


```{r}
#' Gathers all factor levels into one category under suggested name
#
#' @param factor factor vector
#' @param levels.frequency minimal number of cases to preserve original levels
#' @param category.name new name for combined category consisting of rare leves
#
#' @return factor vector with new levels
otherLevel <- function(factor, levels_frequency, category_name) {
  levels(factor)[table(factor) < levels_frequency] <- as.character(category_name)
  return(factor)
}
```


#### Пример с объединением категорий


Создаём фактор с редкими категориями:
  
  
```{r}
fact <- factor(c(rep("c", 100), rep("g", 2), rep("j", 4), rep("v", 10)))
table(fact) # initial state
```


Редкие уровни собраны в категорию "other":
  
  
```{r}
table(otherLevel(fact, 5, "other"))
```


#### Пример с столбиковым графиком (bar plot)


Когда в факторной переменной много уровней (допустим > 8), могут начаться проблемы с построением столбиковых графиков: подписи осей будут накладываться друг на друга (не всегда категории названы "a"), восприятие диаграммы будет осложнено избытком информации. Чтобы избежать этого достаточно объединить редкие категории (уровни/levels) в одну.


Создаём искуственный набор данных:
  
  
```{r}
d <- data.frame(v1 = seq(1:100),
                v2 = factor(c(rep("a", 40),
                              rep("b", 20),
                              rep("c", 20),
                              rep("d", 6), 
                              rep("e", 5),
                              rep("f", 3),
                              rep("g", 3),
                              rep("h", 2),
                              rep("i", 1))))
```


Посмотрим на то, что получилось. v2 --- это фактор с 9 уровнями:
  
  
```{r}
str(d)
```


Столбиковый график (bar plot) v2, до объединения редких уровней:
  
  
```{r}
before_base <- ggplot(data = d, aes(x = v2))
before <- before_base +
  geom_bar() +
  theme_bw()
before
```


Модифицируем v2: объединим редкие уровни (levels) в один под названием "other". Теперь v2 это фактор с 5 уровнями (levels):
  
  
```{r}
d$v2 <- otherLevel(d$v2, 6, "other")
str(d)
```


Столбиковый график (bar plot) после объединения редких уровней (levels):
  
  
```{r}
after_base <- ggplot(data = d, aes(x = v2))
after <- after_base +
  geom_bar() +
  theme_bw()
after
```