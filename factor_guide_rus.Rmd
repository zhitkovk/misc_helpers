---
title: "Дамми и категориальные переменные в R"
author: Константин Житков
output: html_document
---
  
  
### Базовые настройки
  

Начнем с технического момента: установим несколько настроек, чтобы получить итоговый документ без информации о его создании, а также подключим библиотеки для построения графиков и работы с факторными переменными (о том, что такое факторные переменные будет сказано чуть ниже).
  
  
```{r, icnlude = FALSE}
knitr::opts_chunk$set(warning = FALSE)  # убрать предупреждения из документа
knitr::opts_chunk$set(message = FALSE)  # убрать сообщения из документа
```


```{r}
library("ggplot2")  # построение графиков 
library("forcats")  # работа с факторными переменными
```


### Самый просто способ создания дамми переменной (индикатора)


Загрузим данные для построения примеров:
  
  
```{r}
data <- mtcars
```


### Категориальная переменная с двумя уровнями


```{r}
dummy1 <- ifelse(mtcars$hp > 90, "категория1", "категория2")
table(dummy1)
```


### Простой индикатор


```{r}
dummy2 <- ifelse(mtcars$hp > 90, 1, 0)
table(dummy2)
```


### Функция `factor()`


В R дамми и категориальные переменные обычно представляются с помощью факторных переменных. По своей сути переменная типа фактор это числовой (numeric или integer) или текстовый вектор (character) с группировкой каждого уникального значения по категориям/уровням (levels). 


Принцип работы команды проще понять с помощью примеров. Уровни (levels) автоматически устанавливаются на основе уникальных значений:

  
```{r}
fact1 <- factor(c(1, 1, 2))
fact2 <- factor(c("one", "one", "two"))

fact1

fact2
```


Уровням можно давать свои имена. Значения уровней (levels) получены из вектора лэйблов (labels):
  
  
```{r}
fact <- factor(c(1, 1, 2), labels = c("foo", "bar"))

fact
```


Уровни (levels) указаны, но вектор содержит только NA: дело в том, что если уровни (levels) выставлены, то предполагается, что вектор содержит именно эти значения. R пытается найти их в векторе, но не находит и сохраняет заданные значения уровней (levels), отмечая, что наблюдений таких категорий у нас нет:
  
  
```{r}
fact <- factor(c(1, 1, 2), levels = c("foo", "bar"))

fact
```


Пример возможного использования команды `levels`:
  
  
```{r}
fact1 <- factor(c(1, 1, 2), levels = c("1", "2"))
fact2 <- factor(c(1, 1, 2), levels = c("1", "2", "3"))
```


В первом случае мы прописали руками то, что R делает автоматически (создание категорий (уровней/levels) на основе уникальных значений):


```{r}
fact1
```


Во втором случае одному из уровней (level) не соответствует ни одного наблюдения:


```{r}
fact2
```


### Изменение названий уровней


Иногда нам не нравятся названия уровней (levels), полученные на основе уникальных значений вектора. Разберёмся с тем, как переименовать их.


Создаём фактор с уровнями (levels) "1" и "2". Проверяем, что они действительно такие с помощью функции `levels()`:


```{r}
fact <- factor(c(1, 1, 2)) 
levels(fact)
```


Переименовать их в "one" и "two" можно с помощью той же функции `levels()`. Но есть и другой способ. Вернёмся к самому началу заметки. В одном из первых блоков кода мы загрузили пакет `forcats`. Эта библиотека представляет собой обширную коллекцию функций для манипулирования факторами. Да, все операции с факторными переменными можно сделать, пользуясь базовыми командами или придумывая свои функции, но для большинства стандартных случаев можно воспользоваться готовым решением. Далее в заметке будут приведены манипуляции с факторами на основе как базовых команд R, так и команд из пакета `forcats`. 


```{r}
fact <- factor(c(1, 1, 2)) 
levels(fact) <- c("one", "two")

fact
```


`forcats` решение. Результат идентичный, но запись команды позволяет лучше контролировать соответствие новых уровней старым:


```{r}
fact <- factor(c(1, 1, 2)) 
fact <- fct_recode(fact, one = "1", two = "2")

fact
```


### Удаление пустых уровней


Часто после сортировки и фильтрации данных некоторые наблюдения удаляются из выборки. Может так случиться, что теперь какому-то из уровней (level) факторной переменной не соответсвует ни одного наблюдения. Чтобы не таскать за собой эту информацию можно воспользоваться функцией `droplevels()`.


Тоже самое на примере. Создаём фактор:


```{r}
fact <- factor(c(1, 1, 2))
```


Удаляем одно наблюдение:


```{r}
fact <- fact[1:2]
```


Теперь у нас есть один __неиспользованный__ уровень (level). Удалим его:
  
  
```{r}
fact <- droplevels(fact)
fact
```


Или `forcats` решение:


```{r}
fact <- fct_drop(fact)
fact
```


### Изменение порядка уровней


Ещё одной ситуацией требующей манипуляции над факторной переменной является построение регрессии. Мы часто хотим, чтобы __базовой__ категорией была какая-то определенная (женщина, а не мужчина, общее образование, а не среднепрофессиональное etc.). Установить такую категорию несложно: 
  
  
```{r}
fact <- factor(c(1, 1, 2, 3))
fact <- relevel(fact, ref = "2")
```


Теперь "2" стоит в начале:
  
  
```{r}
fact
```


Функция `relevel` из пакета `stats`, которой мы только что воспользовались позволяет перенести в начало лишь _один_ уровень. Если нужно перенести в начало несколько уровней, то нужно пользоваться функцией `fct_relevel`.


На примере:


```{r}
fact <- factor(c(1, 1, 2, 3))
fact <- fct_relevel(fact, "2", "3")
```


Теперь "2" и "3" стоят в начале:


```{r}
fact
```


Кроме как в регрессии подобная манипуляция выручает, если требуется расположить элементы на графике в определенном порядке. Создаём базовый график. "0" означает, что коробка передач в автомобиле автоматическая, "1" соответствует механической коробке.


```{r}
# В самом начале главы мы записали данные mtcars в переменную data

# Переведем числовые (numeric) переменные в factor
data$cyl <- factor(data$cyl)
data$am <- factor(data$am)

# Посмотрим, что вышло
table(data$cyl)
table(data$am)

# Построим график
bar_fill <- ggplot(data = data, aes(x = cyl, fill = am)) +
  geom_bar() +
  scale_fill_discrete(name = "Число\nцилиндров:") +
  labs(x = "Количество цилиндров в автомобиле",
       y = "Количество автомобилей") +
  theme_bw()

bar_fill
```


Допустим, мы хотим, чтобы в легенде сначала отображалась механическая коробка передач. Применяем функцию `fct_relevel` и строим график заново (код для графика не изменился, но, обновились данные, чтобы отобразить эти изменения мы дублируем код для графика):


```{r}
# Меняем порядок уровней
data$am <- fct_relevel(data$am, "1", "0")
table(data$am)


# Строим график
bar_fill <- ggplot(data = data, aes(x = cyl, fill = am)) +
  geom_bar() +
  scale_fill_discrete(name = "Число\nцилиндров:") +
  labs(x = "Количество цилиндров в автомобиле",
       y = "Количество автомобилей") +
  theme_bw()
bar_fill
```


### Объединение редких уровней (levels) в одну категорию ("другое")


Предположим, что на один из вопросов из социологического опроса есть 5 вариантов ответа и большинство людей остановились на первых трёх: 100 человек выбрали первый, 200 второй, 150 третий, 10 четвертый и 7 пятый. Последние два варинта ответа редкие и говорят о каких-то необычных активностях. Такая детализация не всегда нужна, поэтому можно объединить их в одну категорию, к примеру, "другое". 


Такие действия приходится производить достаточно часто и поэтому в пакете `forcats` есть функция для этого. 


### Пример с объединением категорий


Собираем редкие уровни в категорию "other". `n` задаёт количество уровней, которые нужно оставить: допустим у нашего фактора 5 уровней, мы считаем, что 2 из них редкие, тогда мы задаём `n=3` и получаем четвертый уровень, названный в соответствии с аргументом `other_level`.
  

Создаём фактор с редкими категориями:
  
  
```{r}
fact <- factor(c(rep("c", 100), rep("g", 2), rep("j", 4), rep("r", 3), rep("v", 10)))
table(fact)
```


Оставляем 3 самых частых уровня (levels), четвертый называем "other":

  
```{r}
fact <- fct_lump(fact, n = 3, other_level = "other")
table(fact)
```


### Пример с столбиковым графиком (bar plot)


Когда в факторной переменной много уровней (допустим > 8), могут начаться проблемы с построением столбиковых графиков: подписи осей будут накладываться друг на друга (не всегда категории названы "a"), восприятие диаграммы будет осложнено избытком информации. Чтобы избежать этого достаточно объединить редкие категории (уровни/levels) в одну.


Создаём искуственный набор данных:
  
  
```{r}
d <- data.frame(v1 = seq(1:100),
                v2 = factor(c(rep("a", 40),
                              rep("b", 20),
                              rep("c", 20),
                              rep("d", 6), 
                              rep("e", 5),
                              rep("f", 3),
                              rep("g", 3),
                              rep("h", 2),
                              rep("i", 1))))
```


Посмотрим на то, что получилось. v2 --- это фактор с 9 уровнями (levels):
  
  
```{r}
table(d$v2)
```


Столбиковый график (bar plot) v2, до объединения редких уровней (levels):
  
  
```{r}
before<- ggplot(data = d, aes(x = v2)) +
  geom_bar() +
  theme_bw()
before
```


Модифицируем v2: объединим редкие уровни (levels) в один под названием "other". Теперь v2 это фактор с 6 уровнями (levels), один из которых называется `other`. _Внимание_: `n = 5` значит, что мы хотим сохранить 5 самых частых уровней (other), а оставшиеся объединить в новый, поэтому в результате получится 6 уровней:
  
  
```{r}
d$v2 <- fct_lump(d$v2, n = 5, other_level = "other")
table(d$v2)
```


Столбиковый график (bar plot) после объединения редких уровней (levels):
  
  
```{r}
after <- ggplot(data = d, aes(x = v2)) +
  geom_bar() +
  theme_bw()
after
```


### PS


Дополнительные примеры задач, которые могут возникнуть при работе с факторными переменными можно найти в документации к пакету `forcats`.
